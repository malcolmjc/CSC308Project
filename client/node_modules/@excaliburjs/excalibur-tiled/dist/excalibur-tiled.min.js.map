{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///excalibur-tiled.min.js","webpack:///webpack/bootstrap 26f4bbbd4fe3a317874d","webpack:///./src/index.ts","webpack:///external {\"commonjs\":\"excalibur\",\"commonjs2\":\"excalibur\",\"amd\":\"excalibur\",\"root\":\"ex\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__extends","extendStatics","setPrototypeOf","__proto__","Array","b","__","constructor","create","value","TiledMapFormat","excalibur_1","TiledResource","_super","path","mapFormat","JSON","_this","imagePathAccessor","externalTilesetPathAccessor","tileset","indexOf","pp","split","relPath","concat","length","splice","push","join","load","Promise","then","map","promises","data","tilesets","forEach","ts","source","Resource","external","assign","apply","tx","Texture","image","imageTexture","Logger","getInstance","debug","resolve","reject","processData","parseJsonMap","getTilesetForTile","gid","firstgid","getTileMap","TileMap","tilewidth","tileheight","height","width","_i","_a","cols","Math","floor","imagewidth","rows","imageheight","ss","SpriteSheet","registerSpriteSheet","toString","_b","_c","layers","layer","type","sprites","TileSprite","default","encoding","decompressors","decompressBase64","decompressCsv","b64","decode","elt","code","charCodeAt","PLUS","PLUS_URL_SAFE","SLASH","SLASH_URL_SAFE","NUMBER","UPPER","LOWER","v","arr","L","j","tmp","placeHolders","Error","Arr","Uint8Array","len","charAt","resultLen","result","byteArray","slice"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,EAAAG,QAAA,cACA,kBAAAC,gBAAAC,IACAD,QAAA,aAAAJ,GACA,gBAAAC,SACAA,QAAA,oBAAAD,EAAAG,QAAA,cAEAJ,EAAA,oBAAAC,EAAAD,EAAA,KACCO,KAAA,SAAAC,GACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAT,OAGA,IAAAC,GAAAS,EAAAD,IACAE,EAAAF,EACAG,GAAA,EACAZ,WAUA,OANAO,GAAAE,GAAAI,KAAAZ,EAAAD,QAAAC,IAAAD,QAAAQ,GAGAP,EAAAW,GAAA,EAGAX,EAAAD,QAvBA,GAAAU,KA4DA,OAhCAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,SAAAhB,EAAAiB,EAAAC,GACAV,EAAAW,EAAAnB,EAAAiB,IACAG,OAAAC,eAAArB,EAAAiB,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAV,EAAAiB,EAAA,SAAAxB,GACA,GAAAiB,GAAAjB,KAAAyB,WACA,WAA2B,MAAAzB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAO,GAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAjB,KAAAc,EAAAC,IAGtDpB,EAAAuB,EAAA,GAGAvB,IAAAwB,EAAA,KDgBM,SAAU/B,EAAQD,EAASQ,GAEjC,YAEA,IAAIyB,GAAa5B,MAAQA,KAAK4B,WAAc,WACxC,GAAIC,GAAgBd,OAAOe,iBACpBC,uBAA2BC,QAAS,SAAUrB,EAAGsB,GAAKtB,EAAEoB,UAAYE,IACvE,SAAUtB,EAAGsB,GAAK,IAAK,GAAIP,KAAKO,GAAOA,EAAER,eAAeC,KAAIf,EAAEe,GAAKO,EAAEP,IACzE,OAAO,UAAUf,EAAGsB,GAEhB,QAASC,KAAOlC,KAAKmC,YAAcxB,EADnCkB,EAAclB,EAAGsB,GAEjBtB,EAAEa,UAAkB,OAANS,EAAalB,OAAOqB,OAAOH,IAAMC,EAAGV,UAAYS,EAAET,UAAW,GAAIU,OAGvFnB,QAAOC,eAAerB,EAAS,cAAgB0C,OAAO,GE3FtD,IAWYC,GAXZC,EAAApC,EAAA,IAWA,SAAYmC,GAMTA,IAAA,aAKAA,IAAA,gBAXSA,EAAA3C,EAAA2C,iBAAA3C,EAAA2C,mBAcZ,IAAAE,GAAA,SAAAC,GAOG,QAAAD,GAAYE,EAAcC,OAAA,KAAAA,MAAYL,EAAeM,KAArD,IAAAC,GAAA7C,IACG,QAAQ2C,GACL,IAAKL,GAAeM,KACjBC,EAAAJ,EAAAjC,KAAAR,KAAM0C,EAAM,SAAO1C,IACnB,MACH,SACG,KAAM,cAAc2C,EAAS,gEF+FjC,ME5FFE,GAAKF,UAAYA,EACjBE,EAAKC,kBAAoBD,EAAKE,4BAA8B,SAACrB,EAAGsB,GAG7D,GAAuB,IAAnBtB,EAAEuB,QAAQ,KACX,MAAOvB,EAIV,IAAIwB,GAAKR,EAAKS,MAAM,KAChBC,EAAUF,EAAGG,UAOjB,OALIH,GAAGI,OAAS,GAEbF,EAAQG,QAAQ,GAEnBH,EAAQI,KAAK9B,GACN0B,EAAQK,KAAK,MF2EdZ,EEyCf,MArJ2CjB,GAAAY,EAAAC,GAqCjCD,EAAAhB,UAAAkC,KAAP,cAAAb,GAAA7C,KACO0B,EAAI,GAAIa,GAAAoB,OAqDZ,OAnDAlB,GAAAjB,UAAMkC,KAAIlD,KAAAR,MAAG4D,KAAK,SAAAC,GAEf,GAAIC,KAUJjB,GAAKkB,KAAKC,SAASC,QAAQ,SAAAC,GACxB,GAAIA,EAAGC,OAAQ,CACZ,GAAInB,GAAU,GAAIT,GAAA6B,SACfvB,EAAKE,4BAA4BmB,EAAGC,OAAQD,GAAK,OAEpDJ,GAASN,KAAKR,EAAQU,OAAOE,KAAK,SAAAS,GAC9BtD,OAAeuD,OAAOJ,EAAIG,SAOpC9B,EAAAoB,QAAQF,KAAKc,MAAM1B,EAAMiB,GAAUF,KAAK,WAGrCE,KAGAjB,EAAKkB,KAAKC,SAASC,QAAQ,SAAAC,GACxB,GAAIM,GAAK,GAAIjC,GAAAkC,QAAQ5B,EAAKC,kBAAkBoB,EAAGQ,MAAOR,GACtDA,GAAGS,aAAeH,EAClBV,EAASN,KAAKgB,EAAGd,QAEjBnB,EAAAqC,OAAOC,cAAcC,MAAM,uCAAyCZ,EAAGQ,SAG1EnC,EAAAoB,QAAQF,KAAKc,MAAM1B,EAAMiB,GAAUF,KAAK,WACrClC,EAAEqD,QAAQlB,IACV,SAACxB,GACDX,EAAEsD,OAAO3C,MAEZ,SAACA,GACDX,EAAEsD,OAAO3C,OAMRX,GAGHc,EAAAhB,UAAAyD,YAAP,SAAmBlB,GAChB,GAAoB,gBAATA,GACR,KAAM,sBAAsB/D,KAAK0C,KAAI,kCAExC,QAAa,KAATqB,EACD,KAAM,sBAAsB/D,KAAK0C,KAAI,WAGxC,QAAQ1C,KAAK2C,WACV,IAAKL,GAAeM,KACjB,MAAOsC,GAAanB,KAItBvB,EAAAhB,UAAA2D,kBAAP,SAAyBC,GACtB,IAAK,GAAI9E,GAAIN,KAAK+D,KAAKC,SAASV,OAAS,EAAGhD,GAAK,EAAGA,IAAK,CACtD,GAAI4D,GAAKlE,KAAK+D,KAAKC,SAAS1D,EAE5B,IAAI4D,EAAGmB,UAAYD,EAChB,MAAOlB,GAIb,MAAO,OAGH1B,EAAAhB,UAAA8D,WAAP,WAIG,IAAe,GAHXzB,GAAM,GAAItB,GAAAgD,QAAQ,EAAG,EAAGvF,KAAK+D,KAAKyB,UAAWxF,KAAK+D,KAAK0B,WAAYzF,KAAK+D,KAAK2B,OAAQ1F,KAAK+D,KAAK4B,OAGpFC,EAAA,EAAAC,EAAA7F,KAAK+D,KAAKC,SAAV4B,EAAAC,EAAAvC,OAAAsC,IAAkB,CAA5B,GAAI1B,GAAE2B,EAAAD,GACJE,EAAOC,KAAKC,MAAM9B,EAAG+B,WAAa/B,EAAGsB,WACrCU,EAAOH,KAAKC,MAAM9B,EAAGiC,YAAcjC,EAAGuB,YACtCW,EAAK,GAAI7D,GAAA8D,YAAYnC,EAAGS,aAAcmB,EAAMI,EAAMhC,EAAGsB,UAAWtB,EAAGuB,WAEvE5B,GAAIyC,oBAAoBpC,EAAGmB,SAASkB,WAAYH,GAGnD,IAAkB,GAAAI,GAAA,EAAAC,EAAAzG,KAAK+D,KAAK2C,OAAVF,EAAAC,EAAAnD,OAAAkD,IAAgB,CAA7B,GAAIG,GAAKF,EAAAD,EAEX,IAAmB,cAAfG,EAAMC,KACP,IAAK,GAAItG,GAAI,EAAGA,EAAIqG,EAAM5C,KAAKT,OAAQhD,IAAK,CACzC,GAAI8E,GAAcuB,EAAM5C,KAAKzD,EAE7B,IAAY,IAAR8E,EAAW,CACZ,GAAIlB,GAAKlE,KAAKmF,kBAAkBC,EAEhCvB,GAAIE,KAAKzD,GAAGuG,QAAQrD,KAAK,GAAIjB,GAAAuE,WAAW5C,EAAGmB,SAASkB,WAAYnB,EAAMlB,EAAGmB,aAMrF,MAAOxB,IAEbrB,GArJ2CD,EAAA6B,SFuM3CzE,GAAQoH,QAAUvE,CE7ClB,IAAI0C,GAAe,SAACnB,GAGjB,GAAIA,EAAK2C,OACN,IAAkB,GAAAd,GAAA,EAAAC,EAAA9B,EAAK2C,OAALd,EAAAC,EAAAvC,OAAAsC,IAAW,CAAxB,GAAIe,GAAKd,EAAAD,EAEe,iBAAfe,GAAM5C,KAES,WAAnB4C,EAAMK,WACPL,EAAM5C,KAAOkD,EAAcC,iBAAyBP,EAAM5C,KAAM4C,EAAMK,WAIzEL,EAAM5C,KAAOkD,EAAcE,cAAwBR,EAAM5C,MAMlE,MAAOA,IAMNkD,GAKDE,cAAe,SAACpD,GACb,MAAOA,IAOVmD,iBAAkB,SAACE,EAAaJ,GAwB7B,QAAAK,GAAgBC,GACb,GAAIC,GAAOD,EAAIE,WAAW,EAC1B,OAAID,KAASE,GAAQF,IAASG,EAAsB,GAChDH,IAASI,GAASJ,IAASK,EAAuB,GAClDL,EAAOM,GAAgB,EACvBN,EAAOM,EAAS,GAAWN,EAAOM,EAAS,GAAK,GAChDN,EAAOO,EAAQ,GAAWP,EAAOO,EACjCP,EAAOQ,EAAQ,GAAWR,EAAOQ,EAAQ,OAA7C,GAmBH,QAAAvE,GAAcwE,GACXC,EAAIC,KAAOF,EAlDd,GAAI1H,GACD6H,EACA5H,EACA6H,EACAC,EACAJ,CAEH,IAAIb,EAAI9D,OAAS,EAAI,EAClB,KAAM,IAAIgF,OAAM,iDAGnB,IAAIC,GAA6B,mBAAfC,YACbA,WACAxG,MAEDyF,EAAO,IAAID,WAAW,GACtBG,EAAQ,IAAIH,WAAW,GACvBK,EAAS,IAAIL,WAAW,GACxBO,EAAQ,IAAIP,WAAW,GACvBM,EAAQ,IAAIN,WAAW,GACvBE,EAAgB,IAAIF,WAAW,GAC/BI,EAAiB,IAAIJ,WAAW,GAiBhCiB,EAAMrB,EAAI9D,MACd+E,GAAuC,MAAxBjB,EAAIsB,OAAOD,EAAM,GAAa,EAA4B,MAAxBrB,EAAIsB,OAAOD,EAAM,GAAa,EAAI,EAGnFR,EAAM,GAAIM,GAAiB,EAAbnB,EAAI9D,OAAa,EAAI+E,GAGnC9H,EAAI8H,EAAe,EAAIjB,EAAI9D,OAAS,EAAI8D,EAAI9D,MAE5C,IAAI4E,GAAI,CAMR,KAAK5H,EAAI,EAAG6H,EAAI,EAAG7H,EAAIC,EAAGD,GAAK,EAAG6H,GAAK,EACpCC,EAAOf,EAAOD,EAAIsB,OAAOpI,KAAO,GAAO+G,EAAOD,EAAIsB,OAAOpI,EAAI,KAAO,GAAO+G,EAAOD,EAAIsB,OAAOpI,EAAI,KAAO,EAAK+G,EAAOD,EAAIsB,OAAOpI,EAAI,IACnIkD,GAAY,SAAN4E,IAAmB,IACzB5E,GAAY,MAAN4E,IAAiB,GACvB5E,EAAW,IAAN4E,EAGa,KAAjBC,GACDD,EAAOf,EAAOD,EAAIsB,OAAOpI,KAAO,EAAM+G,EAAOD,EAAIsB,OAAOpI,EAAI,KAAO,EACnEkD,EAAW,IAAN4E,IACoB,IAAjBC,IACRD,EAAOf,EAAOD,EAAIsB,OAAOpI,KAAO,GAAO+G,EAAOD,EAAIsB,OAAOpI,EAAI,KAAO,EAAM+G,EAAOD,EAAIsB,OAAOpI,EAAI,KAAO,EACvGkD,EAAM4E,GAAO,EAAK,KAClB5E,EAAW,IAAN4E,GAMR,IAUIO,GAAYV,EAAI3E,OAAS,EACzBsF,EAAS,GAAI5G,OAAc2G,EAE/B,KAAKrI,EAAI,EAAGA,EAAIqI,EAAWrI,IACxBsI,EAAOtI,GAdK,SAAUuI,GAGtB,IAAK,GAFDxG,GAAQ,EAEH/B,EAAIuI,EAAUvF,OAAS,EAAGhD,GAAK,EAAGA,IACxC+B,EAAiB,IAARA,EAA8B,EAAfwG,EAAUvI,EAGrC,OAAO+B,IAOc4F,EAAIa,MAAU,EAAJxI,EAAW,EAAJA,EAAQ,GAGjD,OAAOsI,MFiCP,SAAUhJ,EAAQD,GGpVxBC,EAAAD,QAAAM","file":"excalibur-tiled.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"excalibur\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"excalibur\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Extensions.Tiled\"] = factory(require(\"excalibur\"));\n\telse\n\t\troot[\"Extensions.Tiled\"] = factory(root[\"ex\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"excalibur\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"excalibur\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Extensions.Tiled\"] = factory(require(\"excalibur\"));\n\telse\n\t\troot[\"Extensions.Tiled\"] = factory(root[\"ex\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar excalibur_1 = __webpack_require__(1);\r\nvar TiledMapFormat;\r\n(function (TiledMapFormat) {\r\n    /**\r\n     * TMX map layer format\r\n     * @unsupported\r\n     */\r\n    TiledMapFormat[TiledMapFormat[\"TMX\"] = 0] = \"TMX\";\r\n    /**\r\n     * JSON map layer format\r\n     */\r\n    TiledMapFormat[TiledMapFormat[\"JSON\"] = 1] = \"JSON\";\r\n})(TiledMapFormat = exports.TiledMapFormat || (exports.TiledMapFormat = {}));\r\nvar TiledResource = (function (_super) {\r\n    __extends(TiledResource, _super);\r\n    function TiledResource(path, mapFormat) {\r\n        if (mapFormat === void 0) { mapFormat = TiledMapFormat.JSON; }\r\n        var _this = this;\r\n        switch (mapFormat) {\r\n            case TiledMapFormat.JSON:\r\n                _this = _super.call(this, path, \"json\") || this;\r\n                break;\r\n            default:\r\n                throw \"The format \" + mapFormat + \" is not currently supported. Please export Tiled map as JSON.\";\r\n        }\r\n        _this.mapFormat = mapFormat;\r\n        _this.imagePathAccessor = _this.externalTilesetPathAccessor = function (p, tileset) {\r\n            // Use absolute path if specified\r\n            if (p.indexOf('/') === 0) {\r\n                return p;\r\n            }\r\n            // Load relative to map path\r\n            var pp = path.split('/');\r\n            var relPath = pp.concat([]);\r\n            if (pp.length > 0) {\r\n                // remove file part of path\r\n                relPath.splice(-1);\r\n            }\r\n            relPath.push(p);\r\n            return relPath.join('/');\r\n        };\r\n        return _this;\r\n    }\r\n    TiledResource.prototype.load = function () {\r\n        var _this = this;\r\n        var p = new excalibur_1.Promise();\r\n        _super.prototype.load.call(this).then(function (map) {\r\n            var promises = [];\r\n            // Loop through loaded tileset data\r\n            // If we find an image property, then\r\n            // load the image and sprite\r\n            // If we find a source property, then\r\n            // load the tileset data, merge it with\r\n            // existing data, and load the image and sprite\r\n            _this.data.tilesets.forEach(function (ts) {\r\n                if (ts.source) {\r\n                    var tileset = new excalibur_1.Resource(_this.externalTilesetPathAccessor(ts.source, ts), \"json\");\r\n                    promises.push(tileset.load().then(function (external) {\r\n                        Object.assign(ts, external);\r\n                    }));\r\n                }\r\n            });\r\n            // wait or immediately resolve pending promises\r\n            // for external tilesets\r\n            excalibur_1.Promise.join.apply(_this, promises).then(function () {\r\n                // clear pending promises\r\n                promises = [];\r\n                // retrieve images from tilesets and create textures\r\n                _this.data.tilesets.forEach(function (ts) {\r\n                    var tx = new excalibur_1.Texture(_this.imagePathAccessor(ts.image, ts));\r\n                    ts.imageTexture = tx;\r\n                    promises.push(tx.load());\r\n                    excalibur_1.Logger.getInstance().debug(\"[Tiled] Loading associated tileset: \" + ts.image);\r\n                });\r\n                excalibur_1.Promise.join.apply(_this, promises).then(function () {\r\n                    p.resolve(map);\r\n                }, function (value) {\r\n                    p.reject(value);\r\n                });\r\n            }, function (value) {\r\n                p.reject(value);\r\n            });\r\n        });\r\n        return p;\r\n    };\r\n    TiledResource.prototype.processData = function (data) {\r\n        if (typeof data !== \"object\") {\r\n            throw \"Tiled map resource \" + this.path + \" is not the correct content type\";\r\n        }\r\n        if (data === void 0) {\r\n            throw \"Tiled map resource \" + this.path + \" is empty\";\r\n        }\r\n        switch (this.mapFormat) {\r\n            case TiledMapFormat.JSON:\r\n                return parseJsonMap(data);\r\n        }\r\n    };\r\n    TiledResource.prototype.getTilesetForTile = function (gid) {\r\n        for (var i = this.data.tilesets.length - 1; i >= 0; i--) {\r\n            var ts = this.data.tilesets[i];\r\n            if (ts.firstgid <= gid) {\r\n                return ts;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    TiledResource.prototype.getTileMap = function () {\r\n        var map = new excalibur_1.TileMap(0, 0, this.data.tilewidth, this.data.tileheight, this.data.height, this.data.width);\r\n        // register sprite sheets for each tileset in map\r\n        for (var _i = 0, _a = this.data.tilesets; _i < _a.length; _i++) {\r\n            var ts = _a[_i];\r\n            var cols = Math.floor(ts.imagewidth / ts.tilewidth);\r\n            var rows = Math.floor(ts.imageheight / ts.tileheight);\r\n            var ss = new excalibur_1.SpriteSheet(ts.imageTexture, cols, rows, ts.tilewidth, ts.tileheight);\r\n            map.registerSpriteSheet(ts.firstgid.toString(), ss);\r\n        }\r\n        for (var _b = 0, _c = this.data.layers; _b < _c.length; _b++) {\r\n            var layer = _c[_b];\r\n            if (layer.type === \"tilelayer\") {\r\n                for (var i = 0; i < layer.data.length; i++) {\r\n                    var gid = layer.data[i];\r\n                    if (gid !== 0) {\r\n                        var ts = this.getTilesetForTile(gid);\r\n                        map.data[i].sprites.push(new excalibur_1.TileSprite(ts.firstgid.toString(), gid - ts.firstgid));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return map;\r\n    };\r\n    return TiledResource;\r\n}(excalibur_1.Resource));\r\nexports.default = TiledResource;\r\n/**\r\n * Handles parsing of JSON tiled data\r\n */\r\nvar parseJsonMap = function (data) {\r\n    // Decompress layers\r\n    if (data.layers) {\r\n        for (var _i = 0, _a = data.layers; _i < _a.length; _i++) {\r\n            var layer = _a[_i];\r\n            if (typeof layer.data === \"string\") {\r\n                if (layer.encoding === \"base64\") {\r\n                    layer.data = decompressors.decompressBase64(layer.data, layer.encoding);\r\n                }\r\n            }\r\n            else {\r\n                layer.data = decompressors.decompressCsv(layer.data);\r\n            }\r\n        }\r\n    }\r\n    return data;\r\n};\r\n/**\r\n * Decompression implementations\r\n */\r\nvar decompressors = {\r\n    /**\r\n     * Simplest (passes data through since it's uncompressed)\r\n     */\r\n    decompressCsv: function (data) {\r\n        return data;\r\n    },\r\n    /**\r\n     * Uses base64.js implementation to decode string into byte array\r\n     * and then converts (with/without compression) to array of numbers\r\n     */\r\n    decompressBase64: function (b64, encoding) {\r\n        var i, j, l, tmp, placeHolders, arr;\r\n        if (b64.length % 4 > 0) {\r\n            throw new Error('Invalid string. Length must be a multiple of 4');\r\n        }\r\n        var Arr = (typeof Uint8Array !== 'undefined')\r\n            ? Uint8Array\r\n            : Array;\r\n        var PLUS = '+'.charCodeAt(0);\r\n        var SLASH = '/'.charCodeAt(0);\r\n        var NUMBER = '0'.charCodeAt(0);\r\n        var LOWER = 'a'.charCodeAt(0);\r\n        var UPPER = 'A'.charCodeAt(0);\r\n        var PLUS_URL_SAFE = '-'.charCodeAt(0);\r\n        var SLASH_URL_SAFE = '_'.charCodeAt(0);\r\n        function decode(elt) {\r\n            var code = elt.charCodeAt(0);\r\n            if (code === PLUS || code === PLUS_URL_SAFE)\r\n                return 62; // '+'\r\n            if (code === SLASH || code === SLASH_URL_SAFE)\r\n                return 63; // '/'\r\n            if (code < NUMBER)\r\n                return -1; // no match\r\n            if (code < NUMBER + 10)\r\n                return code - NUMBER + 26 + 26;\r\n            if (code < UPPER + 26)\r\n                return code - UPPER;\r\n            if (code < LOWER + 26)\r\n                return code - LOWER + 26;\r\n        }\r\n        // the number of equal signs (place holders)\r\n        // if there are two placeholders, than the two characters before it\r\n        // represent one byte\r\n        // if there is only one, then the three characters before it represent 2 bytes\r\n        // this is just a cheap hack to not do indexOf twice\r\n        var len = b64.length;\r\n        placeHolders = b64.charAt(len - 2) === '=' ? 2 : b64.charAt(len - 1) === '=' ? 1 : 0;\r\n        // base64 is 4/3 + up to two characters of the original data\r\n        arr = new Arr(b64.length * 3 / 4 - placeHolders);\r\n        // if there are placeholders, only get up to the last complete 4 chars\r\n        l = placeHolders > 0 ? b64.length - 4 : b64.length;\r\n        var L = 0;\r\n        function push(v) {\r\n            arr[L++] = v;\r\n        }\r\n        for (i = 0, j = 0; i < l; i += 4, j += 3) {\r\n            tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));\r\n            push((tmp & 0xFF0000) >> 16);\r\n            push((tmp & 0xFF00) >> 8);\r\n            push(tmp & 0xFF);\r\n        }\r\n        if (placeHolders === 2) {\r\n            tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);\r\n            push(tmp & 0xFF);\r\n        }\r\n        else if (placeHolders === 1) {\r\n            tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);\r\n            push((tmp >> 8) & 0xFF);\r\n            push(tmp & 0xFF);\r\n        }\r\n        // Byte array\r\n        // TODO handle compression\r\n        var toNumber = function (byteArray) {\r\n            var value = 0;\r\n            for (var i = byteArray.length - 1; i >= 0; i--) {\r\n                value = (value * 256) + byteArray[i] * 1;\r\n            }\r\n            return value;\r\n        };\r\n        var resultLen = arr.length / 4;\r\n        var result = new Array(resultLen);\r\n        for (i = 0; i < resultLen; i++) {\r\n            result[i] = toNumber(arr.slice(i * 4, i * 4 + 3));\r\n        }\r\n        return result;\r\n    }\r\n};\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// excalibur-tiled.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 26f4bbbd4fe3a317874d","import {\r\n   Resource,\r\n   Promise,\r\n   Texture,\r\n   TileMap,\r\n   TileSprite,\r\n   SpriteSheet,\r\n   Logger\r\n} from 'excalibur';\r\nimport { ITiledMap, ITiledTileSet } from './ITiledMap';\r\n\r\nexport enum TiledMapFormat {\r\n\r\n   /**\r\n    * TMX map layer format\r\n    * @unsupported\r\n    */\r\n   TMX,\r\n\r\n   /**\r\n    * JSON map layer format\r\n    */\r\n   JSON\r\n}\r\n\r\nexport default class TiledResource extends Resource<ITiledMap> {\r\n\r\n   protected mapFormat: TiledMapFormat;\r\n\r\n   public imagePathAccessor: (path: string, ts: ITiledTileSet) => string;\r\n   public externalTilesetPathAccessor: (path: string, ts: ITiledTileSet) => string;\r\n\r\n   constructor(path: string, mapFormat = TiledMapFormat.JSON) {\r\n      switch (mapFormat) {\r\n         case TiledMapFormat.JSON:\r\n            super(path, \"json\");\r\n            break;\r\n         default:\r\n            throw `The format ${mapFormat} is not currently supported. Please export Tiled map as JSON.`;\r\n      }\r\n\r\n      this.mapFormat = mapFormat;\r\n      this.imagePathAccessor = this.externalTilesetPathAccessor = (p, tileset) => {\r\n\r\n         // Use absolute path if specified\r\n         if (p.indexOf('/') === 0) {\r\n            return p;\r\n         }\r\n\r\n         // Load relative to map path\r\n         let pp = path.split('/');\r\n         let relPath = pp.concat([]);\r\n\r\n         if (pp.length > 0) {\r\n            // remove file part of path\r\n            relPath.splice(-1);\r\n         }\r\n         relPath.push(p);\r\n         return relPath.join('/');\r\n      };\r\n   }\r\n\r\n   public load(): Promise<ITiledMap> {\r\n      var p = new Promise<ITiledMap>();\r\n\r\n      super.load().then(map => {\r\n\r\n         var promises: Promise<any>[] = [];\r\n\r\n         // Loop through loaded tileset data\r\n         // If we find an image property, then\r\n         // load the image and sprite\r\n\r\n         // If we find a source property, then\r\n         // load the tileset data, merge it with\r\n         // existing data, and load the image and sprite\r\n\r\n         this.data.tilesets.forEach(ts => {\r\n            if (ts.source) {\r\n               var tileset = new Resource<ITiledTileSet>(\r\n                  this.externalTilesetPathAccessor(ts.source, ts), \"json\");\r\n\r\n               promises.push(tileset.load().then(external => {\r\n                  (Object as any).assign(ts, external);\r\n               }));\r\n            }\r\n         });\r\n\r\n         // wait or immediately resolve pending promises\r\n         // for external tilesets\r\n         Promise.join.apply(this, promises).then(() => {\r\n\r\n            // clear pending promises\r\n            promises = [];\r\n\r\n            // retrieve images from tilesets and create textures\r\n            this.data.tilesets.forEach(ts => {\r\n               var tx = new Texture(this.imagePathAccessor(ts.image, ts));\r\n               ts.imageTexture = tx;\r\n               promises.push(tx.load());\r\n   \r\n               Logger.getInstance().debug(\"[Tiled] Loading associated tileset: \" + ts.image);\r\n            });\r\n\r\n            Promise.join.apply(this, promises).then(() => {\r\n               p.resolve(map);\r\n            }, (value?: any) => {\r\n               p.reject(value);\r\n            });\r\n         }, (value?: any) => {\r\n            p.reject(value);\r\n         });\r\n\r\n         \r\n      });\r\n\r\n      return p;\r\n   }\r\n\r\n   public processData(data: ITiledMap): ITiledMap {\r\n      if (typeof data !== \"object\") {\r\n         throw `Tiled map resource ${this.path} is not the correct content type`;\r\n      }\r\n      if (data === void 0) {\r\n         throw `Tiled map resource ${this.path} is empty`;\r\n      }\r\n\r\n      switch (this.mapFormat) {\r\n         case TiledMapFormat.JSON:\r\n            return parseJsonMap(data);\r\n      }\r\n   }\r\n\r\n   public getTilesetForTile(gid: number): ITiledTileSet {\r\n      for (var i = this.data.tilesets.length - 1; i >= 0; i--) {\r\n         var ts = this.data.tilesets[i];\r\n\r\n         if (ts.firstgid <= gid) {\r\n            return ts;\r\n         }\r\n      }\r\n\r\n      return null;\r\n   }\r\n\r\n   public getTileMap(): TileMap {\r\n      var map = new TileMap(0, 0, this.data.tilewidth, this.data.tileheight, this.data.height, this.data.width);\r\n\r\n      // register sprite sheets for each tileset in map\r\n      for (var ts of this.data.tilesets) {\r\n         var cols = Math.floor(ts.imagewidth / ts.tilewidth);\r\n         var rows = Math.floor(ts.imageheight / ts.tileheight);\r\n         var ss = new SpriteSheet(ts.imageTexture, cols, rows, ts.tilewidth, ts.tileheight);\r\n\r\n         map.registerSpriteSheet(ts.firstgid.toString(), ss);\r\n      }\r\n\r\n      for (var layer of this.data.layers) {\r\n\r\n         if (layer.type === \"tilelayer\") {\r\n            for (var i = 0; i < layer.data.length; i++) {\r\n               let gid = <number>layer.data[i];\r\n\r\n               if (gid !== 0) {\r\n                  var ts = this.getTilesetForTile(gid);\r\n\r\n                  map.data[i].sprites.push(new TileSprite(ts.firstgid.toString(), gid - ts.firstgid))\r\n               }\r\n            }\r\n         }\r\n      }\r\n\r\n      return map;\r\n   }\r\n}\r\n\r\n/**\r\n * Handles parsing of JSON tiled data\r\n */\r\nvar parseJsonMap = (data: ITiledMap): ITiledMap => {\r\n   \r\n   // Decompress layers\r\n   if (data.layers) {\r\n      for (var layer of data.layers) {\r\n\r\n         if (typeof layer.data === \"string\") {\r\n\r\n            if (layer.encoding === \"base64\") {\r\n               layer.data = decompressors.decompressBase64(<string>layer.data, layer.encoding);\r\n            }\r\n\r\n         } else {\r\n            layer.data = decompressors.decompressCsv(<number[]>layer.data);\r\n         }\r\n\r\n      }\r\n   }\r\n\r\n   return data;\r\n}\r\n\r\n/**\r\n * Decompression implementations\r\n */\r\nvar decompressors = {\r\n\r\n   /**\r\n    * Simplest (passes data through since it's uncompressed)\r\n    */\r\n   decompressCsv: (data: number[]) => {\r\n      return data;\r\n   },\r\n\r\n   /**\r\n    * Uses base64.js implementation to decode string into byte array\r\n    * and then converts (with/without compression) to array of numbers\r\n    */\r\n   decompressBase64: (b64: string, encoding: string) => {\r\n      var i: number,\r\n         j: number,\r\n         l: number,\r\n         tmp: number,\r\n         placeHolders: number,\r\n         arr: number[] | Uint8Array;\r\n\r\n      if (b64.length % 4 > 0) {\r\n         throw new Error('Invalid string. Length must be a multiple of 4')\r\n      }\r\n\r\n      var Arr = (typeof Uint8Array !== 'undefined')\r\n         ? Uint8Array\r\n         : Array;\r\n\r\n      var PLUS = '+'.charCodeAt(0);\r\n      var SLASH = '/'.charCodeAt(0);\r\n      var NUMBER = '0'.charCodeAt(0);\r\n      var LOWER = 'a'.charCodeAt(0);\r\n      var UPPER = 'A'.charCodeAt(0);\r\n      var PLUS_URL_SAFE = '-'.charCodeAt(0);\r\n      var SLASH_URL_SAFE = '_'.charCodeAt(0);\r\n\r\n      function decode(elt) {\r\n         var code = elt.charCodeAt(0)\r\n         if (code === PLUS || code === PLUS_URL_SAFE) return 62 // '+'\r\n         if (code === SLASH || code === SLASH_URL_SAFE) return 63 // '/'\r\n         if (code < NUMBER) return -1 // no match\r\n         if (code < NUMBER + 10) return code - NUMBER + 26 + 26\r\n         if (code < UPPER + 26) return code - UPPER\r\n         if (code < LOWER + 26) return code - LOWER + 26\r\n      }\r\n\r\n      // the number of equal signs (place holders)\r\n      // if there are two placeholders, than the two characters before it\r\n      // represent one byte\r\n      // if there is only one, then the three characters before it represent 2 bytes\r\n      // this is just a cheap hack to not do indexOf twice\r\n      var len = b64.length\r\n      placeHolders = b64.charAt(len - 2) === '=' ? 2 : b64.charAt(len - 1) === '=' ? 1 : 0\r\n\r\n      // base64 is 4/3 + up to two characters of the original data\r\n      arr = new Arr(b64.length * 3 / 4 - placeHolders)\r\n\r\n      // if there are placeholders, only get up to the last complete 4 chars\r\n      l = placeHolders > 0 ? b64.length - 4 : b64.length\r\n\r\n      var L = 0\r\n\r\n      function push(v) {\r\n         arr[L++] = v\r\n      }\r\n\r\n      for (i = 0, j = 0; i < l; i += 4, j += 3) {\r\n         tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\r\n         push((tmp & 0xFF0000) >> 16)\r\n         push((tmp & 0xFF00) >> 8)\r\n         push(tmp & 0xFF)\r\n      }\r\n\r\n      if (placeHolders === 2) {\r\n         tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\r\n         push(tmp & 0xFF)\r\n      } else if (placeHolders === 1) {\r\n         tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\r\n         push((tmp >> 8) & 0xFF)\r\n         push(tmp & 0xFF)\r\n      }\r\n\r\n      // Byte array\r\n      // TODO handle compression\r\n\r\n      var toNumber = function (byteArray: number[] | Uint8Array) {\r\n         var value = 0;\r\n\r\n         for (var i = byteArray.length - 1; i >= 0; i--) {\r\n            value = (value * 256) + byteArray[i] * 1;\r\n         }\r\n\r\n         return value;\r\n      };\r\n\r\n      var resultLen = arr.length / 4;\r\n      var result = new Array<number>(resultLen);\r\n\r\n      for (i = 0; i < resultLen; i++) {\r\n         result[i] = toNumber(arr.slice(i * 4, i * 4 + 3));\r\n      }\r\n\r\n      return result;\r\n   }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"excalibur\",\"commonjs2\":\"excalibur\",\"amd\":\"excalibur\",\"root\":\"ex\"}\n// module id = 1\n// module chunks = 0 1"],"sourceRoot":""}